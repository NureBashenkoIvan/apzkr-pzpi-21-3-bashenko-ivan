Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для створення та керування бізнес-процесами з використанням автоматів швидкого приготування сублімованої їжі

Студент гр. ПЗПІ-21-3 	__________________ Башенко І. О.
 (підпис)
Керівник роботи 		__________________ доц. Лещинська І.О.
 (підпис)
Роботу захищено «__»_________2024р. з оцінкою _________________________

 Комісія: 				__________________ доц. Лещинська І.О.
(підпис)
     ________________ доц. Лещинський В.О.
    (підпис)
  _________________ст.викл.Сокорчук І.П.
(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки 
 
Факультет комп’ютерних наук__________ Кафедра програмної інженерії__ 
Спеціальність 121-Інженерія програмного забезпечення_________________ 
Курс ____3_____Семестр_________________6________________________
Дисципліна Архітектура програмного забезпечення___________________ 
 
ЗАВДАННЯ  
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ 
 
____________________Башенко Івану Олександровичу________________
1. Тема роботи: Програмна система для створення та керування бізнес-процесами з використанням автоматів швидкого приготування сублімованої їжі                                                                                                                                 2. Термін узгодження завдання з лабораторних робіт «4»  березня_2024 р.
3. Термін здачі завдання з лабораторних робіт «15» _червня_ 2024 р. 
4. Вихідні дані до проекту (роботи): У програмній системі для автоматів швидкого харчування передбачено: авторизацію та створення нових акаунтів для користувачів автоматів та їхніх власників; редагування, додавання та видалення даних щодо блюд, налаштувань автоматів, їхніх типів, їхніх виробників; створення замовлень та їхня обробка і виконання за допомогою розумного пристрою – автомата швидкого приготування сублімованої їжі; налаштування стану автоматів, включаючи попередження про несправності та необхідність обслуговування; створення резервних копій бази даних та управління користувачами і їхніми ролями у системі. Використовувати ОС Windows 10 або 11, систему управління базами даних Microsoft SQL Server 2019, редактор коду Visual Studio Code, середовище розробки Microsoft Visual Studio 2022, C#, а також фреймворки ASP.NET Core 8.0 для серверної частини; редактор коду Visual Code, мову програмування С++ та симулятор WokWi для частини інтернету речей.                                                                                                                                                        
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки.                                                                                                                     
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
Діаграми розгортання, діаграми прецедентів, діаграми пакетів, діаграма компонентів, діаграма взаємодії, діаграма діяльності, ER-модель даних, архітектурна структура серверної частини проекту, структура та схема ІоТ пристрою.                                                                                                            




















КАЛЕНДАРНИЙ ПЛАН 

 
№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація програмного проекту	06.03.2024	виконано
2	Проектування програмного
проекту	08.03.2024	виконано
3	Кодування програмного проекту	13.05.2024	виконано
4	Оформлення пояснювальної
записки	02.06.2024	виконано
5	Захист курсової роботи	13.06.2024	виконано
 
 
Дата видачі теми завдання «4» березня 2024 р.  
 
Керівник 				 _____________ доц. Лещинська І.О.
(підпис)
	

 
Завдання прийняв до виконання 
ст. гр. ПЗПІ-21-3 	 	 	 	 	 ___________Башенко І.О. 
(підпис)




РЕФЕРАТ

Пояснювальна записка до курсової роботи: 66 с., 16 рис., 3 табл., 3 додатки, 6 джерел.
АВТОМАТ ШВИДКОГО ПРИГОТУВАННЯ, АВТОМАТИЗАЦІЯ, ВЛАСНИК БІЗНЕСУ, ІНТЕРНЕТ РЕЧЕЙ, КЛІЄНТ, MICROSOFT SQL SERVER, ПЛАТФОРМА .NET CORE 8.0, РЕЗЕРВНА КОПІЯ БАЗИ ДАНИХ, СТВОРЕННЯ ЗАМОВЛЕНЬ, СУБЛІМОВАНА ЇЖА, УПРАВЛІННЯ АВТОМАТАМИ.
Об'єктом моєї дослідницької роботи є розробка програмної системи для керування автоматами швидкого приготування їжі. Автоматизація в галузі швидкого харчування є актуальною та важливою проблемою, оскільки вона дозволить оптимізувати процеси приготування їжі, зменшити людський фактор та підвищити ефективність обслуговування клієнтів.
Метою моєї роботи є створення інтелектуальної програмної системи, яка дозволить не лише оптимізувати процеси приготування сублімованої їжі в автоматах, але й полегшить організацію бізнесу для власників таких автоматів. Основна мета полягає у забезпеченні гнучкості та індивідуалізації для клієнтів, а також у покращенні ефективності та контролю для власників автоматів.
Методи розробки включають платформу .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0, систему авторизації та аутентифікації ASP.NET Core Identity, та СУБД Microsoft SQL Server 2019, які разом складають серверну частину проекту. Функціонування ІоТ пристрою засноване на використанні мікроконтролера ESP32.
	У результаті дослідження та розробки програмної системи було створено інноваційний продукт, який дозволяє власникам автоматів ефективно керувати їхньою роботою. Ця програмна система не лише надає зручний спосіб замовлення страв для клієнтів, але й дозволяє власникам моніторити та контролювати роботу своїх автоматів, включаючи контроль якості та відстеження статусу.

ЗМІСТ

ВСТУП	8
1 БІЗНЕС-ВИМОГИ	9
1.1 Передумови	9
1.2 Бізнес-можливості	10
1.3 Бізнес-цілі та критерії успіху	12
1.4 Потреби клієнтів та ринку	13
1.5 Бізнес-ризики	14
2 КОНЦЕПЦІЇ РІШЕННЯ	16
2.1 Окреслення концепції	16
2.2 Головна функціональність	16
2.3 Припущення та залежності	17
3 РАМКИ ТА ОБМЕЖЕННЯ	20
3.1 Рамки первинного випуску	20
3.2 Рамки наступних випусків	20
3.3 Обмеження та винятки	21
4 БІЗНЕС-КОНТЕКСТ	23
4.1 Профілі зацікавлених сторін	23
4.2 Пріоритети проєкту	25
4.3 Робоче середовище	26
5 СЕРВЕРНА ЧАСТИНА	27
5.1 Опис інженерних рішень	27
5.2 Розробка діаграм	30
5.3 Специфікація REST	33
5.4 Опис частин програмного коду	40
6 ПРИСТРІЙ ІНТЕРНЕТУ РЕЧЕЙ	44
6.1 Опис інженерних рішень	44
6.2 Пояснення програмного коду	45
6.3 Розробка діаграм	47
ВИСНОВКИ	50
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	51
ДОДАТОК А	52
ДОДАТОК Б	59
ДОДАТОК В	66

























ВСТУП

	У сучасному світі автоматизація в галузі швидкого харчування стала ключовим чинником в організації та оптимізації процесів обслуговування. Автомати швидкого харчування є невід'ємною складовою міського життя, забезпечуючи не лише швидку доступність їжі, але й відкриваючи нові можливості для гасла «харчування на ходу».
	Зростаючий попит на ефективні рішення в галузі гастрономії та зміна побутових звичок суспільства роблять автомати швидкого харчування надзвичайно актуальними. Відповідно, ефективне управління автоматами та оптимізація їх функціонування вимагають вдосконалених інструментів та рішень.
	Метою моєї роботи є створення програмної системи для управління автоматами швидкого харчування, що відповідає вимогам сучасного ринку та забезпечує якісне обслуговування клієнтів. Ця система має включати в себе розроблені інструменти для ефективного планування ресурсів, моніторингу стану автоматів, аналізу даних та автоматизації процесів замовлення та приготування їжі.
	В рамках роботи буде проведено аналіз поточних рішень на ринку, визначені основні вимоги до програмної системи та розроблена відповідна архітектура. Крім того, буде здійснено випробування розробленої системи з метою підтвердження її ефективності та функціональності. Таким чином, ця курсова робота спрямована на створення інноваційного інструменту для оптимізації управління автоматами швидкого харчування та покращення обслуговування в цій галузі.
1 БІЗНЕС-ВИМОГИ
1.1 Передумови

Створення програмної системи для управління бізнес-процесами з використанням автоматів швидкого приготування сублімованої їжі є ключовою ініціативою в галузі громадської харчової промисловості. В контексті зростаючої популярності швидкого харчування та постійного збільшення попиту на зручні та ефективні рішення для приготування їжі, програмна система стане важливим інструментом для підтримки підприємств та їхніх клієнтів у цій сфері. 
Ця ініціатива має на меті забезпечити зручність, швидкість та ефективність у створенні та управлінні бізнес-процесами в галузі швидкого харчування за допомогою автоматів швидкого приготування сублімованої їжі. Наша система ставить перед собою завдання підтримувати підприємства у впровадженні інноваційних методів приготування їжі, що відповідають сучасним вимогам споживачів та технологічним тенденціям. 
Програмна система буде надійним інструментом для створення та управління різноманітними бізнес-процесами, пов'язаними з використанням автоматів швидкого приготування сублімованої їжі. Вона дозволить підприємствам оптимізувати виробничі процеси, забезпечуючи якість продукції та збільшуючи ефективність використання ресурсів.
Не тільки в світі, але й в Україні, завдяки розвиненій аграрній індустрії та традиціям споживання свіжих продуктів, існує потенціал для впровадження автоматів швидкого приготування сублімованої їжі, які б використовували локально вирощені інгредієнти. Це не тільки підвищить якість кінцевого продукту, але й забезпечить підтримку місцевих виробників.
Проте, існують виклики, пов’язані з логістикою та зберіганням продуктів, особливо в умовах, коли потрібно забезпечити швидке приготування їжі без втрати її поживних властивостей. Також важливим є забезпечення доступності цих автоматів у різних регіонах країни, щоб кожен мав можливість скористатися сучасними та здоровими варіантами харчування.
Наша програмна система враховує ці особливості, пропонуючи рішення, яке оптимізує ланцюги постачання, забезпечує якість продуктів та їх своєчасну доставку до автоматів. Таким чином, система не тільки вирішує проблему доступності здорового харчування, але й сприяє розвитку місцевого бізнесу та економіки в цілому, враховуючи екологічні аспекти та потреби сучасного споживача. 

1.2 Бізнес-можливості

	На ринку вже існують компанії, що пропонують рішення для автоматизації процесів у галузі швидкого харчування. Наприклад, у США існує платформа Zume, яка використовує роботів для автоматизації процесу приготування піци та інших страв шляхом використання швидкого приготування сублімованої їжі. У Китаї компанія Haidilao [1] використовує роботизовані системи для приготування та подачі готових страв у своїх ресторанах, забезпечуючи швидкий та якісний сервіс для клієнтів. У Європі є також проекти, що ставлять перед собою мету автоматизувати процеси готування їжі, такі як проект Moley Robotics, який розробляє роботизовані кухні для використання у ресторанах та домашніх умовах.
	Наша програмна система для автоматів швидкого приготування сублімованої їжі створена для задоволення потреб сучасного ринку, який шукає зручність, швидкість та якість. Вона приваблює увагу не тільки великих ресторанних мереж, які прагнуть автоматизувати свої процеси, але й індивідуальних підприємців, які бажають відкрити власний бізнес у сфері харчування.
	Наша система забезпечує ефективність у сфері громадського харчування, оптимізуючи час приготування їжі та зменшуючи витрати на персонал. Вона також цінна для торгових центрів, аеропортів, житлових комплексів та інших місць з великою прохідністю людей, де зручність та швидкість обслуговування є ключовими.
	Для індивідуальних підприємців наша система стає ключовим інструментом для входження на ринок з мінімальними витратами та забезпечення високоякісного обслуговування. Ми відкриваємо можливості для інновацій та підтримки локальних продуктів, що робить нашу систему привабливою для тих, хто цінує свіжість та якість.
	Наша розробка передбачає різні види монетизації:
1.	Підписка: пропонуючи ресторанам, офісним центрам або житловим комплексам щомісячну або щорічну передплату, ми відкриваємо для них доступ до нашої інноваційної системи управління автоматами швидкого приготування. Це не лише спрощує процес замовлення та доставки їжі, але й надає можливість аналізувати дані про споживачів для оптимізації меню та запасів. Підписка також включає технічну підтримку та регулярні оновлення програмного забезпечення, що гарантує безперебійну роботу автоматів.
2.	Партнерство: співпраця з постачальниками продуктів та обладнання дозволяє нам розширювати асортимент інгредієнтів та впроваджувати новітні технології в автомати. Це підвищує якість страв та задоволення клієнтів. Партнерство може також включати спільні маркетингові кампанії та спеціальні пропозиції, що залучають нових споживачів та підтримують інтерес до автоматів.
3.	Реклама: рекламний простір на автоматах та в мобільному додатку є цінним активом, який ми можемо запропонувати брендам та компаніям. Вони можуть рекламувати свої товари та послуги, досягаючи великої аудиторії активних споживачів. Реклама може бути цільовою, враховуючи переваги та звички користувачів, що забезпечує високу ефективність маркетингових кампаній.

1.3 Бізнес-цілі та критерії успіху

Бізнес-цілі (BO - Business Objectives):
BO-1: Збільшити обсяг продажів програмної системи на 50% протягом першого року.
BO-2: Забезпечити стабільну та надійну роботу програмної системи для всіх користувачів.
BO-3: Покрити 80% ринку швидкого харчування за два роки з моменту введення системи на ринок.
BO-4: Стати лідером у сфері автоматизації бізнес-процесів у галузі швидкого приготування їжі протягом трьох років.
BO-5: Створити ефективну мережу партнерів та постачальників інгредієнтів для швидкого приготування їжі.
Критерії успіху (SC - Success Criteria):
SC-1: Перевищення мети у встановленні програмної системи на ринку, досягнувши понад 1000 активних клієнтів протягом першого року.
SC-2: Забезпечення стабільної роботи системи без жодних відмов протягом року.
SC-3: Отримання позитивних відгуків від не менше 80% користувачів програмної системи протягом першого року експлуатації.
SC-4: Зростання популярності швидкого харчування та активне використання програмної системи у регіонах, де раніше цей тип харчування не був популярним.
SC-5: Здійснення прибутку від використання програмної системи, що складає не менше 10% від загального обороту компанії протягом першого року її впровадження.



1.4 Потреби клієнтів та ринку

Потреби клієнтів та ринку наступні:
1. Потреба в забезпеченні безперебійної роботи автоматів швидкого приготування сублімованої їжі. Клієнти мають потребу в надійності та безперебійній роботі автоматів для отримання якісної їжі у будь-який час доби.
2. Потреба в швидкості та зручності приготування їжі. Клієнти системи швидкого харчування цінують швидкість та зручність процесу приготування їжі за допомогою автоматів, що дозволяє їм ефективно використовувати свій час та отримувати страви без зайвих затримок.
3. Потреба в доступності та прозорій ціновій політиці. Клієнти мають потребу в доступній та прозорій ціновій політиці, що дозволяє їм зручно розраховувати витрати на їжу та вибирати оптимальний варіант для себе.
4. Потреба в якості та смакових якостях страв. Клієнти системи швидкого приготування їжі шукають якісні та смачні страви, які відповідають їхнім смаковим уподобанням та вимогам до якості продукту.
5. Потреба в інноваційних та екологічно чистих рішеннях. Клієнти цінують інноваційні та екологічно чисті рішення, що сприяють збереженню навколишнього середовища та підвищенню ефективності використання ресурсів.
6. Потреба в розвиненій системі безпеки та захисту користувачів. Клієнти швидкого харчування мають потребу в надійній системі безпеки та захисту, що гарантує їхню безпеку та захищеність під час використання автоматів для приготування їжі. 
7. Потреба в ефективному та надійному управлінні бізнес-процесами. Власники автоматів швидкого харчування потребують ефективних та надійних систем управління бізнес-процесами, що дозволяють їм ефективно контролювати та оптимізувати роботу своїх автоматів, враховуючи попит на продукцію, стан обладнання та інші фактори.
Система «Om-Nom-Box» розроблена з урахуванням цих потреб, надаючи ринку продукт, який допомагає клієнтам насолоджуватись якісною та смачною їжею швидко та зручно, забезпечуючи при цьому доступність, ефективність та екологічну безпеку, а також надаючи власникам автоматів швидкого харчування інструменти та можливості для ефективного та надійного управління їхнім бізнесом. Завдяки цій системі власники можуть отримати доступ до даних про роботу автоматів, здійснювати моніторинг та аналіз ефективності, а також приймати управлінські рішення на основі об'єктивних даних та аналізу ринкових тенденцій.

1.5 Бізнес-ризики

Бізнес-ризики:
1. Ризик обмеженого попиту через низьку поширеність автоматів швидкого приготування сублімованої їжі. Може виникнути ризик недостатнього попиту на послуги системи через обмежену аудиторію або низький рівень свідомості про переваги швидкого приготування сублімованої їжі. Для зменшення цього ризику потрібно проводити маркетингові дослідження та активно просувати переваги системи перед конкурентами.
2. Ризик конкуренції на ринку швидкого харчування. Існує ризик високої конкуренції від інших систем швидкого приготування їжі, що може призвести до втрати ринкової частки та зниження прибутковості. Для запобігання цьому ризику необхідно розробити унікальні функціональні можливості системи та акцентувати увагу на її перевагах перед конкурентами.
3. Ризик технологічних збоїв та аварій. Існує ризик технологічних збоїв у роботі програмної системи, обладнання для швидкого приготування їжі або автоматів, що може призвести до перерв у роботі та негативно вплинути на репутацію бізнесу. Для зменшення цього ризику слід забезпечити регулярне технічне обслуговування та вчасне виявлення та усунення несправностей.
4. Ризик юридичних обмежень та санкцій. Може виникнути ризик порушення нормативно-правових вимог у сфері харчової промисловості або торгівлі, що може призвести до штрафів, санкцій або втрати ліцензій. Для запобігання цьому ризику необхідно дотримуватися всіх вимог законодавства та вести чіткий юридичний контроль.	
5. Ризик обмеженого доступу до електроенергії. Існує ризик обмеженого доступу до електроенергії, що може виникнути через перебої у електропостачанні або недостатню потужність електромережі. Це може призвести до зменшення ефективності роботи системи та негативно вплинути на задоволення потреб користувачів. Для зменшення цього ризику необхідно розробити стратегії резервного живлення та співпрацювати з місцевими постачальниками електроенергії.
Для забезпечення успішної реалізації проекту необхідно виявляти та управляти цими бізнес-ризиками, розробляючи стратегії їхнього управління та мінімізації. Активне управління цими ризиками дозволить забезпечити стабільність та успіх проекту в умовах змінного бізнес-середовища.






2 КОНЦЕПЦІЇ РІШЕННЯ
2.1 Окреслення концепції

	Мета нашого продукту полягає в створенні інтелектуальної програмної системи, яка не лише оптимізує процеси приготування сублімованої їжі, полегшує організацію бізнесу власникам автоматів швидкого приготування, але й дозволить клієнтам контролювати процес приготування їжі, забезпечуючи гнучкість та індивідуалізацію.
Продукт, який ми пропонуємо, це інноваційна програмна система, що дозволить власникам автоматів швидкого приготування керувати їхньою роботою, включаючи контроль якості, відстеження статусу роботи тощо,  і все це з використанням автоматизованих бізнес-процесів.
Продукт, який ми розробляємо, буде особливо корисним для власників приміщень з великою прохідністю людей, де можна розмістити автомати швидкого приготування, таких як офісні комплекси, торгові центри та готелі, а також для постачальників сублімованої їжі. Крім того, наша система зацікавить і користувачів, які шукають швидкий та смачний перекус у будь-який час дня.
Наша концепція базується на аналізі ринку швидкого харчування та інноваційних технологій в галузі програмного забезпечення. Ми прагнемо створити продукт, який буде відповідати найвищим стандартам якості та безпеки, а також забезпечить найбільшу задоволеність і зручність для споживачів та власників бізнесу.

2.2 Головна функціональність

Головна функціональність (MF – Major Feature): 
MF-1: Моніторинг статусу автоматів швидкого приготування їжі та попередження про несправності або необхідність обслуговування.
МF-2: Можливість клієнтів замовляти страви за допомогою API, вибираючи з різноманітного меню сублімованих страв, а також мати можливість запускати процес готування.
МF-3: Реєстрація користувачів-клієнтів та зберігання їхніх профілів з особистою інформацією, включаючи вподобання щодо харчування, алергії та інші специфічні вимоги. Реєстрація користувачів-власників бізнесу та можливість детального та зручного керування їхніми автоматами швидкого приготування.
МF-4: Формування звітності про обсяги продажів, популярність конкретних страв, а також відслідковування ефективності роботи автоматів.
МF-5: Використання сучасних технологій IoT для моніторингу рівня запасів інгредієнтів в автоматах, температури та інших параметрів, що впливають на якість приготування страв, а також мати можливість готувати їжу та видавати її клієнту.

2.3 Припущення та залежності

Припущення:
1. Припущення щодо користувачів - припускається, що власники бізнесу, які використовують автомати швидкого приготування їжі, будуть здійснювати замовлення через API, і що вони будуть активно користуватися цією системою для управління своїми автоматами та замовленнями.
2. Доступ до Інтернету - припускається, що власники бізнесу та їхні клієнти матимуть стабільний доступ до Інтернету для взаємодії з програмною системою та здійснення замовлень.
3. Регуляторні норми та стандарти - припускається, що програмна система буде відповідати всім необхідним регуляторним нормам та стандартам безпеки та якості в країнах, де вона буде запроваджена.
4. Доступність джерел енергії - припускається, що автомати швидкого приготування їжі матимуть постійний доступ до джерел енергії для функціонування та надання послуг.
5. Конкурентоспроможність продукту - припускається, що програмна система буде мати конкурентні переваги перед існуючими або потенційними альтернативами на ринку автоматів швидкого приготування їжі.
Залежності:
1. Залежність від постачання продуктів харчування - система залежить від постійного та надійного постачання необхідних інгредієнтів та сировини для автоматів швидкого приготування їжі. Це включає постачання свіжих продуктів, інгредієнтів для приготування сублімованої їжі, а також додаткових матеріалів, таких як упаковка та посуд. Нестабільність у постачанні або недоліки в якості продуктів можуть негативно вплинути на функціонування системи та задоволення клієнтів. Тому важливо мати надійних постачальників та механізми контролю якості продукції.
2. Залежність від наявності електроенергії - залежність від того, що автомати швидкого приготування їжі матимуть постійний доступ до достатньої кількості електроенергії для своєї роботи.
3. Оновлення програмного забезпечення - потреба у регулярному оновленні програмного забезпечення роботів та мобільних додатків для покращення функціональності та безпеки системи.
4. Переваги перед конкурентами - залежність від аналізу конкурентного середовища та відповідного реагування на конкурентну динаміку.
5. Залежність від законодавства - необхідність дотримання всіх відповідних законодавчих норм та правил у країнах, де функціонує програмна система для управління автоматами швидкого приготування їжі.

























3 РАМКИ ТА ОБМЕЖЕННЯ
3.1	 Рамки первинного випуску

Серверна частина програмної системи надаватиме користувачам наступний функціонал:
1. Створення облікових записів для користувачів (користувачів автоматів швидкого приготування їжі, компаній, які їх мають).
2. Система авторизації та аутентифікації для безпечного доступу до системи.
3. Створення, редагування та видалення записів про автомати швидкого харчування, типи їжі та дані про користувача.
4. Оформлення замовлення на постачання сублімованих страв для наповнення автоматів швидкого приготування їжі.
5. Обробка замовлень та підтвердження виконаних замовлень.
6. Захист персональних даних користувачів.
7. Можливість створення резервного копіювання інформації для власників компаній.
У якості IoT буде використовуватися автомат швидкого приготування їжі:
1. Обробка API-запитів щодо приготування конкретного типу їжі.
2. Приготування обраного блюда.
3. Відображення інформації про приготування блюда та стан автомату на LED-панелі та динаміку.

3.2 Рамки наступних випусків

Наступні випуски системи «Om-Nom-Box» будуть спрямовані на постійне вдосконалення та доповнення функціональності, щоб задовольнити зростаючі потреби користувачів та реагувати на ринкові вимоги. Планується реалізація таких функціональних можливостей у майбутніх випусках:
Додаткова аналітика та звітність: додаткові засоби для аналізу та візуалізації даних щодо ефективності виконання замовлень щодо приготування їжі, швидкості виконання замовлень конкретним постачальником.
Розширення можливостей для власників автоматів швидкого приготування їжі: розвиток інструментів для оформлень замовлення, більш гнучке сортування та управління автоматами.

3.3 Обмеження та винятки

Обмеження:
1. Технологічні обмеження - система може бути обмежена технологічними характеристиками автоматів швидкого приготування їжі та мережевими обмеженнями. Робота системи може залежати від наявності стабільного інтернет-з'єднання та сумісного обладнання.
	2. Безпека та надійність - не можна гарантувати 100% безпеку та надійність системи. Існують ризики втрати даних, злому, крадіжки, пошкодження або несправності роботів, аварій або інцидентів під час приготування їжі.
	3. Законодавче регулювання - збір та аналіз даних про користувачів та їхні замовлення повинен здійснюватися з дотриманням нормативів конфіденційності та всіх законодавчих обмежень щодо збору та обробки особистої інформації. Також потрібно враховувати закони та регуляції різних країн, щодо роздрібної торгівлі харчовими продуктами та безпеки їжі.
Винятки:
	1. Призначення для автоматів швидкого приготування їжі - система спеціалізується на оптимізації процесу приготування їжі в автоматах швидкого харчування, тому надання послуг для інших типів автоматів виключено.
	2. Ліцензійні обмеження - використання певних технологій приготування їжі або ресурсів може обмежуватися ліцензійними угодами з компаніями-виробниками автоматів швидкого приготування їжі.
	3. Логістичні обмеження - доступність системи може бути обмежена логістичними аспектами, такими як обмежена мобільність автоматів або складнощі їхнього розміщення в певних місцях.
	4. Можливості користувачів - користувачам потрібно мати смартфон або інший пристрій, що дозволяє замовляти та оплачувати послуги, а також отримувати інформацію про статус замовлення та доступність автоматів. Користувачі також зобов'язані дотримуватися правил безпеки під час користування системою.














4 БІЗНЕС-КОНТЕКСТ
4.1 Профілі зацікавлених сторін

Таблиця 4.1 – Профілі зацікавлених сторін
Зацікавлені сторони	Основна цінність	Ставлення	Основні інтереси	Обмеження
Користувачі-клієнти	Швидке та зручне харчування	Очікують високої якості продукту та сервісу	Замовлення та отримання якісної їжі швидко та зручно, вибір меню	Обмеження в різноманітності або кількості доступних страв у конкретному автоматі, що може не задовольняти всі смакові уподобання клієнтів.
Власники автоматів	Збільшення продажів через підвищення зручності	Очікують підвищення прибутку та впізнавання	Реалізація автоматів, підвищення їхньої популярності, партнерство	Бюджетні обмеження, технічні обмеження для розміщення апаратів
Постачальники	Розширення ринку збуту через нові канали продажів	Очікують підвищення замовлень та прибутку	Співпраця з системою, постачання інгредієнтів, партнерство	Обмеження виробничих можливостей, логістичні складнощі

Таблиця 4.1 – Продовження таблиці
Рекламодавці, які хочуть розміщувати свою рекламу на автоматах швидкого приготування їжі або сайті	Досягнення великої аудиторії потенційних клієнтів, які користуються послугами автомата швидкого приготування їжі або відвідують наш сайт	Очікують надання ефективних та доступних каналів реклами, а також можливості аналізувати результати своїх рекламних кампаній	Укладання договорів з нами, створення та запуск рекламного контенту, отримання зворотного зв'язку та статистики про перегляди та конверсії	Бюджетні обмеження, технологічні обмеження щодо формату та якості рекламного контенту, нормативні обмеження щодо етики та законності реклами












4.2 Пріоритети проєкту

Таблиця 4.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (діапазон можливостей)
Графік	Випуск MVP відбувається до 25.05	Випуск MVP відбувається не пізніше, ніж через 10 днів після дедлайну	MVP може вийти в реліз до 05.05
Функціонал	Для версії 1.0 має бути готово 70% функціоналу.	Завершеність функціоналу не є більш ніж на 30% нижчою за очікувану	Включення 65-70% важливих та пріоритетних функцій у версію 1.0
Якість	Система має проходити 100% тестів, бути стабільною в усіх сценаріях та не мати критичних помилок.	Ресурси та час для тестування	Можлива відсутність доступу до системи через проведення технічного обслуговування автоматів швидкого харчування
Персонал	Розмір команди: 1 розробник.	Розробляється 1 людиною.	Достатній рівень навичок для створення продукту.
Ціна	Бюджет 50 тисяч доларів. На версію 1.0 витратити 65% бюджету, на 1.1 – інші 35%.	Для версії 1.0 витрати не перевищують 3%, для 1.1 – 5%.	Перевищення бюджету до 10% прийнятне без розгляду керівництвом.
4.3 Робоче середовище

Робоче середовище проекту складається з наступних технологій для розробки своїх компонентів: C# і .NET 8 для серверної частини, ASP.NET Core 8.0 для API, DataGrip для бази даних, Entity Framework Core 8.0 для роботи з базою даних, AutoMapper, Swagger, NLog в якості бібліотек для серверної частини. ESP32 та Wokwi, Servo-мотори, LED-панель, діодні лампи та динамік, а також Arduino IDE та Visual Studio Code, C++ 23  для IoT пристрою.
Вимоги щодо доступності, надійності, продуктивності та цілісності будуть визначені окремо для кожного компонента системи, з урахуванням вимог зацікавлених сторін та стандартів галузі. Розробка та тестування будуть здійснені з метою забезпечення високої якості та надійності продукту в робочому середовищі.










5 СЕРВЕРНА ЧАСТИНА
5.1 Опис інженерних рішень

Проект розроблено на мові програмування C#, яка входить до складу платформи .NET, з використанням фреймворку ASP.NET Core Web API 8. Для зберігання даних використовується Microsoft SQL Server, а для взаємодії з базою даних - Entity Framework Core 8.0. Для автентифікації та авторизації використовується ASP.NET Core Identity, а також ASP.NET Core Authentication. Серверна частина програмної системи має багаторівневу Onion-архітектуру [2] з окремими проектами, які були створені в середовищі розробки, які включають рівні представлення, репозиторія, доступ до даних, сервіси, контракти тощо.
Будова архітектури проекту наступна:
1.	OmNomBox.API – це початкова точка входу в проект, яка містить в собі конфігурацію, реєстрацію всіх сервісів за допомогою Dependency Injection [3] та відповідає за налаштування профілю маппінгу для всього застосунку.

 
Рисунок 5.1 – Структура OmNomBox.API
2.	Entities – проект, який відповідає за доменний рівень та містить в собі моделі, тобто сутності. Також він має моделі помилок.

 
Рисунок 5.2 – Структура Entities

3.	Contracts та Repository – це сервісні проекти, які реалізовують патерн Repository та допомагають працювати напряму з провайдером бази даних.

 
Рисунок 5.3 – Структура Contracts
 
Рисунок 5.4 – Структура Repository

4.	Service.Contracts та Service – це проєкти, які відповідають за шар сервісу, який виконує безпосередньо бізнес-логіку та взаємодіє з репозиторієм.

 
Рисунок 5.5 – Структура Service та Service.Contracts
5.	LoggerService, Shared та OmNomBox.API.Presentation – проекти, які відповідають за інфраструктурну частину, а також частину презентації. Наприклад, Shared містить в собі DataTransferObjects, LoggerService відповідає за логування дій, а OmNomBox.API.Presentation має контролери.

 
Рисунок 5.6 – Структура OmNomBox.API.Presentation

5.2 Розробка діаграм

Було розроблено ER-модель, яка складається з 9 сутностей. На ній є наступні зв’язки: 
– «Users» - «Companies» та «Users» - «Orders» мають зв’язок
один-до-багатьох;
– «Machines» - «Orders» та «Orders» - «Meals» мають також зв’язок один-до-багатьох;
– «Users» - «Companies», «Companies» - «Machines», «Machines» - «MachineStatuses», «Manufacturers» - «Machines» та «MachineTypes» - «Machines» мають зв’язок один-до-багатьох;
– «Meals» - «MachineSettings» та «MachineTypes» - «MachineSettings» мають зв’язок багато-до-багатьох;
	ER-модель зображена на рисунку 5.7.

 
Рисунок 5.7 – ER-модель даних

Діаграма розгортання складається із 3 елементів (рис. 5.8): серверу на ASP.NET Core Web API, бази даних на MSSQL та робота на ESP32.

 
Рисунок 5.8 – Діаграма розгортання
Для розуміння того, як користувачі взаємодіють з системою, була створена діаграма прецедентів (Use Case Diagram) (рис. 5.9). У системі існують два актори: користувач та адміністратор. На діаграмі можна побачити, що управління компаніями, управління блюдами та детальне управління апаратами харчування доступне тільки адміністратору, оскільки користувач має змогу тільки реєструватися, щоб робити замовлення та переглядати їх. Також адміністратор має можливість зробити резервне копіювання бази даних.

 
Рисунок 5.9 – Діаграма прецедентів

Було створено діаграму пакетів (Package Diagram), яка ілюструє різні рівні архітектури програмної системи (рис. 5.10). Ця діаграма показує взаємозв'язки між пакетами та способи їх використання одне одним для виконання своїх завдань. На ній відображено 6 пакетів: Users, Orders, Machines, Companies, IoT Devices та Meals.

 
Рисунок 5.10 – Діаграма пакетів
	
5.3 Специфікація REST

У рамках роботи з даними за принципами REST API кожна HTTP-дія відповідає певному виду операції: наприклад, POST використовується для створення, PUT для оновлення, DELETE для видалення, а GET для отримання запису. REST-специфікація описує ендпоїнти для керування користувачами, компаніями, апаратами, замовленнями, виробниками, їжею, типами апаратів, статусами апаратів та їх налаштуваннями. Вона включає в себе різноманітні операції для реєстрації та авторизації користувачів, отримання списків і деталей об'єктів, створення, оновлення та видалення записів. Адміністратор має розширені можливості доступу до інформації про користувачів, компанії, апарати, замовлення та інші сутності, а також можливість створювати і керувати різними записами в системі. Користувачі мають можливість отримувати інформацію про свої компанії, апарати та замовлення, а також керувати ними. 

Таблиця 5.1 – Специфікація REST API
Посилання	Метод	Призначення
/api/authentication	POST	Реєстрація нового користувача
/api/authentication/login	POST	Авторизація користувача
/api/users/	GET	Отримання адміністратором інформації про всіх користувачів
/api/users/{key}	DELETE	Видалення користувача адміністратором
/api/companies/admin	GET	Отримання адміністратором списку всіх компаній 
/api/companies	GET	Отримання користувачем списку його компаній
/api/companies/{key}	GET	Отримання інформації про компанію
/api/companies/
?pageNumber={key}
&pageSize={key}	GET	Отримання користувачем списку його компаній за допомогою пагінації


	Продовження таблиці 5.1
/api/companies/?searchTerm
={key}	GET	Отримання користувачем списку його компаній за допомогою пошуку
/api/companies/?orderBy={key} asc	GET	Отримання користувачем списку його компаній за допомогою сортування
/api/companies	POST	Створення користувачем його компанії
/api/companies/{key}	UPDATE	Оновлення даних про компанію користувачем
/api/companies/{key}	DELETE	Видалення запису про компанію
/api/companies/{key}/machines/admin	GET	Отримання адміністратором списку апаратів
/api/companies/{key}/machines	GET	Отримання списку апаратів користувача
/api/companies/{key}/machines?pageNumber={key}
&pageSize={key}	GET	Отримання а списку апаратів за допомогою пагінації


Продовження таблиці 5.1
/api/companies/{key}/machines ?orderBy={key} asc	GET	Отримання списку апаратів за допомогою сортування
/api/companies/{key}/machines/
{key}	GET	Отримання інформації про апарат
/api/companies/{key}/machines/
	POST	Створення адміністратором апарату
/api/companies/{key}/machines/
{key}	UPDATE	Оновлення даних про апарат
/api/companies/{key}/machines/
{key}	DELETE	Видалення запису про апарат
/api/orders/admin	GET	Отримання адміністратором списку всіх замовлень
/api/orders/	GET	Отримання користувачем списку своїх замовлень
/api/orders/{key}	GET	Отримання інформації про замовлення
/api/orders/
?orderBy={key} asc	GET	Отримання користувачем списку замовлень за допомогою сортування
/api/orders/admin	GET	Отримання адміністратором списку всіх замовлень
/api/orders	POST	Створення користувачем замовлення

Продовження таблиці 5.1
/api/orders{key}	DELETE	Видалення адміністратором запису про замовлення
/api/orders{key}	UPDATE	Оновлення запису про замовлення
/api/manufacturers	GET	Отримання адміністратором списку виробників апаратів
/api/manufacturers/{key}	GET	Отримання адміністратором інформації про виробника апаратів
/api/manufacturers/
?pageNumber={key}
&pageSize={key}	GET	Отримання адміністратором списку виробників апаратів за допомогою пагінації
/api/manufacturers	POST	Створення адміністратором виробника апаратів
/api/manufacturers/{key}	UPDATE	Оновлення даних про виробника апаратів адміністратором
/api/manufacturers/{key}	DELETE	Видалення запису про виробника апаратів
/api/backup/create	POST	Створення бекапу бази даних адміністратором
/api/meals	GET	Отримання адміністратором списку їжі
/api/meals/{key}	GET	Отримання адміністратором інформації про блюдо

Продовження таблиці 5.1
/api/meals/
?pageNumber={key}
&pageSize={key}	GET	Отримання адміністратором списку їжі за допомогою пагінації
/api/meals	POST	Створення адміністратором блюда
/api/meals/{key}	UPDATE	Оновлення даних про блюдо
/api/meals/{key}	DELETE	Видалення запису про блюдо
/api/machineTypes	GET	Отримання адміністратором списку типів апаратів
/api/machineTypes/{key}	GET	Отримання адміністратором інформації про тип апарату
/api/machineTypes/
?pageNumber={key}
&pageSize={key}	GET	Отримання адміністратором списку типів апаратів за допомогою пагінації
/api/machineTypes	POST	Створення адміністратором типу апарату
/api/machineTypes/{key}	UPDATE	Оновлення даних про тип апарату
/api/machineTypes/{key}	DELETE	Видалення запису про тип апарату
/api/machineStatuses	GET	Отримання адміністратором списку статусів апаратів
/api/machineStatuses/{key}	GET	Отримання адміністратором інформації про статуси апаратів

Продовження таблиці 5.1
/api/machineStatuses/
?pageNumber={key}
&pageSize={key}	GET	Отримання адміністратором списку статусів апаратів за допомогою пагінації
/api/machineStatuses	POST	Створення адміністратором статусу апарату
/api/machineStatuses/{key}	UPDATE	Оновлення даних про статус апарату
/api/machineStatuses/{key}	DELETE	Видалення запису про статус апарату
/api/machineTypes/{key}/
machineSettings/admin	GET	Отримання адміністратором списку налаштувань апаратів
/api/machineTypes/{key}/
machineSettings	GET	Отримання адміністратором інформації про налаштування апарату
/api/machineTypes/{key}/
machineSettings
?pageNumber={key}
&pageSize={key}	GET	Отримання адміністратором списку налаштувань апаратів за допомогою пагінації
/api/machineTypes/{key}/
machineSettings
	POST	Створення адміністратором налаштування апарату
/api/machineTypes/{key}/
machineSettings/{key}
	UPDATE	Оновлення запису налаштування апарату
/api/machineTypes/{key}/
machineSettings/{key}
	DELETE	Видалення запису налаштування апарату
/api/machineTypes	GET	Отримання адміністратором списку типів апаратів

5.4 Опис частин програмного коду
5.4.1 Аутентифікація

	Аутентифікація відбувається за допомогою JWT-токенів та бібліотеки ASP.NET Core Identity. Повний код наведений в додатку А.
Щоб увійти у систему користувач повинен надіслати адресу своєї електронної пошти та пароль. Після цього вони валідуються на сервері із використанням методів ASP.NET Core Identity та формується JWT-токен. 
Створюється токен за допомогою метода GenerateTokenOptions(), код якого наступний:
1 var jwtSettings = _configuration.GetSection("JwtSettings");
2  var tokenOptions = new JwtSecurityToken
3  (issuer: jwtSettings["validIssuer"],
4    audience: jwtSettings["validAudience"],
5    claims: claims,
6 expires:DateTime.Now.AddMinutes(Convert.ToDouble(jwtSettings["expires"])),
7     signingCredentials: signingCredentials);
10  return tokenOptions;

5.4.2 Обробник помилок

Також можемо продемонструвати налаштування обробника винятків у програмі, який використовує мідлвару для обробки помилок веб-запитів:
1 public static void ConfigureExceptionHandler(this WebApplication app, ILoggerManager logger)
2 {
3     app.UseExceptionHandler(appError =>
4     {
5         appError.Run(async context =>
6         {
7             context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
8             context.Response.ContentType = "application/json";
9             var contextFeature = context.Features.Get<IExceptionHandlerFeature>();
10             if (contextFeature != null)
11             {
12                 context.Response.StatusCode = contextFeature.Error switch
13                 {
14                     NotFoundException => StatusCodes.Status404NotFound,
15                     _ => StatusCodes.Status500InternalServerError
16                 };
17                 logger.LogError($"Something went wrong: {contextFeature.Error}");
18                 await context.Response.WriteAsync(new ErrorDetails()
19                 {
20                     StatusCode = context.Response.StatusCode,
21                     Message = contextFeature.Error.Message,
22                 }.ToString());
23             }
24         });
25     });
26 }

Цей метод перехоплює будь-які винятки, що виникають під час обробки запитів, і встановлює відповідний HTTP-статус відповіді залежно від типу помилки. Якщо виникає помилка типу "NotFoundException", встановлюється статус 404 (не знайдено), у протилежному випадку - статус 500 (внутрішня помилка сервера). Крім того, він логує деталі помилки та повертає інформацію про помилку у форматі JSON.

5.4.3 Використання Dependency Injection

Також в проекті використовується Dependency Injection, який полягає в тому, щоб класи отримували залежності зовні, замість того, щоб самостійно їх створювати. Це допомагає вирішувати проблему залежностей між класами, полегшує їхнє тестування та робить код більш гнучким. Повний код продемонстрований в додатку А. Фрагмент коду наступний:
1  public static void ConfigureLoggerSerivce(this IServiceCollection services)
2 => services.AddSingleton<ILoggerManager, LoggerManager>();

5.4.4 Використання Validation Filter

Поміж іншого, в проекті також використовується Validation Filter [4]. Validation filter - це фільтр, який використовується у веб-застосунках для перевірки та валідації вхідних даних. Він дозволяє встановлювати правила для перевірки коректності даних, переданих у запиті, і забезпечує можливість відповіді з помилкою в разі невідповідності цим правилам. Це може бути використано для перевірки формату даних, обов'язкових полів, а також для власних правил валідації. Використання валідаційних фільтрів сприяє підтримці консистентності даних системи та забезпечує більш безпечну обробку запитів у проекті. Код наведений в додатку А.

 
6 ПРИСТРІЙ ІНТЕРНЕТУ РЕЧЕЙ
6.1 Опис прийнятих інженерних рішень

Для створення програмного забезпечення для IoT-пристрою використовувався симулятор Wokwi [5]. Програмний код для пристрою був розроблений мовою програмування C++. Цей IoT-пристрій є автоматом швидкого приготування їжі, який може готувати та подавати різні страви за допомогою кількох сервомоторів, звукових сигналів і світлових індикаторів. Пристрій дозволяє користувачам замовляти страви через сервер, після чого автомат обробляє замовлення та готує страву відповідно до вказаних параметрів. Використовуючи три сервомотори, автомат виконує обертання для приготування та подання їжі. Світлодіоди сигналізують про процес приготування, готовність страви та інші стани, а динамік забезпечує звукові сигнали для інформування про готовність страви чи про помилки. Склад пристрою включає мікроконтролер ESP32, три сервомотори для приготування, один сервомотор для подання їжі, кнопку, динамік, світлодіоди та дисплей (рис. 6.1).

 
Рисунок 6.1 – Будова IoT-пристрою
6.2 Пояснення програмного коду

Після активації пристрій автоматично підключається до WiFi-мережі (див. додаток Б). Після цього він створює вебсервер на порту 80, який слухатиме вхідні HTTP-запити. Користувач може замовити приготування страви через сервер, вказуючи ідентифікатор страви та кількість. Після отримання запиту, пристрій починає обробку в методі handleOrderRequest та виконує приготування в handleDishPreparation, а потім чекає на натискання кнопки для подачі страви через метод dispenseDish, прив’язаний до BUTTON_PIN. Код методу handleOrderRequest наступний:
1 void handleOrderRequest() {
2   if (server.hasArg("dish") && server.hasArg("quantity")) {
3     String dishId = server.arg("dish");
4     int quantity = server.arg("quantity").toInt();
5     if (isValidDishId(dishId) && quantity > 0) {
6       DishConfig dish = getDishConfigById(dishId);
7       Serial.print("Preparing ");
8       Serial.print(dish.name);
9       Serial.print(" x");
10      Serial.println(quantity);
11      handleDishPreparation(dish, quantity);
12      server.send(200, "text/plain", "Dish prepared");
13    } else {
14      handleUnsupportedDish();
15      server.send(200, "text/plain", "Unsupported Dish Type");
16    }
17  } else {
18    server.send(400, "text/plain", "Bad Request");
19  }
20 }
У методі handleDishPreparation оберти сервомоторів виконуються згідно з налаштуваннями страви (див. додаток Б). Після завершення приготування, пристрій сигналізує про готовність страви світлодіодом та звуковим сигналом. Метод handleDishPreparation наступний:
1 void handleDishPreparation(DishConfig dish, int quantity) {
2   turnOnYellowLight();
3   String quantityStr = "Qty: " + String(quantity);
4   displayMessage(dish.name, quantityStr.c_str());
5   for (int i = 0; i < dish.servo1Rotations * quantity; ++i) {
6     servo1.write(0);
7     servo2.write(0);
8     delay(750);
9     servo1.write(180);
10    servo2.write(180);
11    delay(750);
12  }
13  servo1.write(90);
14  servo2.write(90);
15  turnOffYellowLight();
16  beep(1, 500);
17  turnOnGreenLight();
18  displayMessage(dish.name, "Ready");
19 }
Після приготування страви, пристрій чекає на натискання кнопки для подачі страви. Метод dispenseDish виконує подачу страви за допомогою сервомотора, який обертається на 180 градусів для кожної одиниці страви. Код методу dispenseDish наступний:
1 void dispenseDish(DishConfig dish, int quantity) {
2   int rotations = quantity * 2;
3   for (int i = 0; i < rotations; ++i) {
4     servo3.write(0);
5     delay(1000);
6     servo3.write(180);
7     delay(1000);
8   }
9   servo3.write(90);
10  turnOffAllLights();
11  displayMessage("", "");
12 }
При натисканні кнопки, метод dispenseDish викликається для подачі приготованої страви, що дозволяє автомату ефективно та точно виконувати свої функції.

6.3 Діаграми

Для автомата швидкого приготування, тобто IoT-пристрою, було розроблено діаграму прецедентів (рис. 6.2). Акторами було призначено звичайного користувача системою та адміністратора. Виглядає діаграма наступним чином:

 
Рисунок 6.2 – Діаграма прецедентів
	Також була зроблена діаграма активності (рис. 6.3), яка показує повний процес роботи IoT-пристрою:

 
Рисунок 6.3 – Діаграма активності

Була зроблена діаграма взаємодії (рис. 6.4), яка дозволяє візуалізувати взаємодію всіх компонентів IoT-пристрою між собою та показує повний процес обробки команд між складовими програми:






 
Рисунок 6.4 – Діаграма взаємодії

Також була зроблена діаграма пакетів (рис. 6.5) яка візуалізує організацію системи чи програми на рівні пакетів (групування модулів, класів або компонентів).

 
Рисунок 6.5 – Діаграма пакетів


ВИСНОВКИ

	Після завершення цієї курсової роботи стало очевидним, що програмна система для керування автоматами швидкого харчування пройшла через важливий етап розробки, викликаючи настільки суттєві зміни в цілому процесі обслуговування. Насамперед, вона забезпечує широкий спектр можливостей для клієнтів та адміністраторів, починаючи від можливості швидкої реєстрації та створення облікових записів, і закінчуючи зручними інструментами для моніторингу та аналізу даних про замовлення та витрати. Такий комплексний підхід дозволяє ефективно керувати бізнесом, забезпечуючи задоволення потреб як клієнтів, так і персоналу.
	Крім того, система створює нові можливості для автоматизації рутинних операцій та оптимізації процесів. Вона пропонує інноваційні методи реєстрації та авторизації, що забезпечують зручність і безпеку у взаємодії з автоматами. Крім того, вона реалізує механізми автоматичного відстеження та аналізу попиту, що дозволяє адаптувати асортимент та пропозиції до потреб клієнтів, забезпечуючи більшу конкурентоспроможність та ефективність.
	Для розробки були задіяні наступні технології: платформу .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0, систему авторизації та аутентифікації ASP.NET Core Identity, та СУБД Microsoft SQL Server 2019, які разом складають серверну частину проекту. Функціонування ІоТ пристрою засноване на використанні мікроконтролера ESP32.
	У результаті функціонального тестування виявлено, що програмна система відповідає всім вимогам щодо якості та працездатності, що дає підстави для вірогідності успіху її реалізації в реальних умовах. 
	Таким чином, ця робота не лише вирішує конкретні завдання з управління автоматами швидкого харчування, але й пропонує зручний сервіс користування ними.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. About Haidilao. Haidilao. URL: https://www.haidilao-inc.com/us/about/ (дата звернення: 08.06.2024). 
2. Onion Architecture in ASP.NET Core. CodeMaze. URL: https://code-maze.com/onion-architecture-in-aspnetcore/ (дата звернення: 08.06.2024). 
3. .NET dependency injection. Learn Microsoft.  URL: https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection (дата звернення: 08.06.2024).
4. Filters in ASP.NET Core Web API. Learn Microsoft. URL: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0 (дата звернення: 08.06.2024). 
5. Wokwi Docs. Wokwi. URL: https://docs.wokwi.com/ (дата звернення: 08.06.2024).
6. GitHub - NureBashenkoIvan/apzkr-pzpi-21-3-bashenko-ivan. GitHub. URL: https://github.com/NureBashenkoIvan/apzkr-pzpi-21-3-bashenko-ivan (дата звернення: 08.06.2024).
7. Іван Башенко. Демонстрація курсової АПЗ ПЗПІ 21 3 Башенко Іван. YouTube. URL: https://youtu.be/9CARAAzsLEQ  (дата звернення: 15.06.2024).









ДОДАТОК А
Програмний код серверної частини
	А.1 Код файлу «ServiceExtensions.cs»
1 using System.Text
2 using Contracts
3 using Entities.Models
4 using LoggerService
5 using Microsoft.AspNetCore.Authentication.JwtBearer
6 using Microsoft.AspNetCore.Identity
7 using Microsoft.EntityFrameworkCore
8 using Microsoft.IdentityModel.Tokens
9 using Microsoft.OpenApi.Models
10 using Repository
11 using Service
12 using Service.Contracts
13 namespace Lumotech.Extensions
14 public static class ServiceExtensions
15 {
16     public static void ConfigureCors(this IServiceCollection 	services) =>
17         services.AddCors(options =>
18         {
19             options.AddPolicy("CorsPolicy", builder =>
20                 builder.AllowAnyOrigin()
21                     .AllowAnyMethod()
22                     .AllowAnyHeader());
23         });
24     public static void ConfigureIdentity(this 	IServiceCollection services)
25     {
26         var builder = services.AddIdentity<User, 	IdentityRole>(o =>
27             {
28                 o.Password.RequireDigit = true;
29                 o.Password.RequireLowercase = false;
30                 o.Password.RequireUppercase = false;
31                 o.Password.RequireNonAlphanumeric = false;
32                 o.Password.RequiredLength = 8;
33                 o.User.RequireUniqueEmail = true;
34             })
35             .AddEntityFrameworkStores<RepositoryContext>()
36             .AddDefaultTokenProviders();
37     }
38     public static void ConfigureJWT(this IServiceCollection 	services, IConfiguration configuration)
39     {
40         var jwtSettings = 	configuration.GetSection("JwtSettings");
41         var secretKey = 	Environment.GetEnvironmentVariable("SECRET");
42         services.AddAuthentication(opt =>
43             {
44                 opt.DefaultAuthenticateScheme = 	JwtBearerDefaults.AuthenticationScheme;
45                 opt.DefaultChallengeScheme = 	JwtBearerDefaults.AuthenticationScheme;
46             })
47             .AddJwtBearer(options =>
48             {
49                 options.TokenValidationParameters = new 	TokenValidationParameters
50                 {
51                     ValidateIssuer = true,
52                     ValidateAudience = true,
53                     ValidateLifetime = true,
54                     ValidateIssuerSigningKey = true,
55                     ValidIssuer = jwtSettings["validIssuer"],
56                     ValidAudience = 	jwtSettings["validAudience"],
57                     IssuerSigningKey = 
58                         new 	SymmetricSecurityKey(Encoding.UTF8.GetBytes("VanyavidiviciSecretK	eySecretKeySecretKey"))
59                 };
60             });
61     }
62     public static void ConfigureSwagger(this 	IServiceCollection services)
63     {
64         services.AddSwaggerGen(s =>
65         {
66             s.SwaggerDoc("v1", new OpenApiInfo { Title = 	"OmNomBox API", Version = "v1"
67             });
68             
69             s.AddSecurityDefinition("Bearer", new 	OpenApiSecurityScheme
70             {
71                 In = ParameterLocation.Header,
72                 Description = "Place to add JWT with Bearer",
73                 Name = "Authorization",
74                 Type = SecuritySchemeType.ApiKey,
75                 Scheme = "Bearer"
76             });
77             
78             s.AddSecurityRequirement(new 	OpenApiSecurityRequirement()
79             {
80                 {
81                     new OpenApiSecurityScheme
82                     {
83                         Reference = new OpenApiReference
84                         {
85                             Type = 	ReferenceType.SecurityScheme,
86                             Id = "Bearer"
87                         },
88                         Name = "Bearer",
89                     },
90                     new List<string>()
91                 }
92             });
93         });
94     }
95     public static void ConfigureLoggerSerivce(this 	IServiceCollection services)
96         => services.AddSingleton<ILoggerManager, 	LoggerManager>();
97     public static void ConfigureRepositoryManager(this 	IServiceCollection services) =>
98         services.AddScoped<IRepositoryManager, 	RepositoryManager>();
99     public static void ConfigureServiceManager(this 	IServiceCollection services) =>
100         services.AddScoped<IServiceManager, 	ServiceManager>();
101     public static void ConfigureSqlContext(this 	IServiceCollection services, IConfiguration configuration) => 
102         	services.AddSqlServer<RepositoryContext>((configuration.GetConnec	tionString("sqlConnection")));
103 }
А.2 Код файлу «AuthenticationService.cs»
1 using System.IdentityModel.Tokens.Jwt
2 using System.Security.Claims
3 using System.Text
4 using AutoMapper
5 using Contracts
6 using Entities.Models
7 using Microsoft.AspNetCore.Identity
8 using Microsoft.Extensions.Configuration
9 using Microsoft.IdentityModel.Tokens
10 using Service.Contracts
11 using Shared.DataTransferObjects
12 namespace Service
13 internal sealed class AuthenticationService : 	IAuthenticationService
14 {
15     private readonly ILoggerManager _logger
16     private readonly IMapper _mapper
17     private readonly UserManager<User> _userManager
18     private readonly IConfiguration _configuration
19     private User? _user
20     public AuthenticationService(ILoggerManager logger, 	IMapper mapper, UserManager<User> userManager, 
21         IConfiguration configuration)
22     {
23         _logger = logger
24         _mapper = mapper
25         _userManager = userManager
26         _configuration = configuration
27     }   
28     public async Task<IdentityResult> 	RegisterUser(UserForRegistrationDto userForRegistration)
29     {
30         var user = _mapper.Map<User>(userForRegistration)
31         
32         var result = await _userManager.CreateAsync(user, 	userForRegistration.Password)
33         
34         if (result.Succeeded)
35             await _userManager.AddToRolesAsync(user, 	userForRegistration.Roles)
36         
37         return result
38     }
39     public async Task<bool> 	ValidateUser(UserForAuthenticationDto userForAuth)
40     {
41         _user = await 	_userManager.FindByEmailAsync(userForAuth.Email)
42         
43         var result = (_user != null && await 	_userManager.CheckPasswordAsync(_user,
44             userForAuth.Password))
45         
46         if (!result)
47             _logger.LogWarn($"{nameof(ValidateUser)}: 	Authentication failed. Wrong email or password.")
48         
49         return result
50         
51     } 
52     public async Task<string> CreateToken()
	А.3 Код файлу «ValidationFilter.cs»
1 using Microsoft.AspNetCore.Mvc;
2 using Microsoft.AspNetCore.Mvc.Filters;
3 namespace Lumotech.Presentation.ActionFilters
4 {
5     public class ValidationFilterAttribute : IActionFilter
6     {
7         public ValidationFilterAttribute()
8         {
9         } 
10         public void OnActionExecuting(ActionExecutingContext 	context)
11         {
12             var action = context.RouteData.Values["action"];
13             var controller = 	context.RouteData.Values["controller"];    
14             var param = context.ActionArguments
15                 .SingleOrDefault(x => 	x.Value.ToString().Contains("Dto")).Value;
16             if (param is null)
17             {
18                 context.Result = 
19                     new BadRequestObjectResult($"Object is 	null. Controller: {controller}, action: {action}");
20                 return;
21             }
22             if (!context.ModelState.IsValid)
23                 context.Result = new 	UnprocessableEntityObjectResult(context.ModelState);
24         }
25         public void OnActionExecuted(ActionExecutedContext 	context)
26         {
27         }
28     }
29 }

















ДОДАТОК Б
Програмний код ІоТ пристрою
Б.1 Код файлу «esp32-http-server.ino»
1#include <WiFi.h>
2#include <WiFiClient.h>
3#include <WebServer.h>
4#include <uri/UriBraces.h>
5#include "DishConfig.h"
6#include "DisplayHandler.h"
7#include "LightBuzzerHandler.h"
8#include "ServoHandler.h"
9#include "WiFiConfig.h"
10#include "PinConfig.h"
11
12WebServer server(80);
13
14void sendHtml() {
15  String response = R"(
16    <!DOCTYPE html><html>
17      <head>
18        <title>ESP32 Web Server Demo</title>
19        <meta name="viewport" content="width=device-	width, initial-scale=1">
20        <style>
21          html { font-family: sans-serif; text-align: 	center; }
22          body { display: inline-flex; flex-direction: 	column; }
23          h1 { margin-bottom: 1.2em; } 
24          h2 { margin: 0; }
25          div { display: grid; grid-template-columns: 1fr 	1fr; grid-template-rows: auto auto; grid-auto-flow: column; 	grid-gap: 1em; }
26          .btn { background-color: #5B5; border: none; 	color: #fff; padding: 0.5em 1em;
27                 font-size: 2em; text-decoration: none }
28          .btn.OFF { background-color: #333; }
29        </style>
30      </head>
31            
32      <body>
33        <h1>ESP32 Web Server</h1>
34        <div>
35          <h2>Order a Dish</h2>
36          <form action="/order" method="get">
37            <label for="dish">Dish ID:</label>
38            <input type="text" id="dish" 	name="dish"><br><br>
39            <label for="quantity">Quantity:</label>
40            <input type="text" id="quantity" 	name="quantity"><br><br>
41            <input type="submit" value="Submit">
42          </form>
43        </div>
44      </body>
45    </html>
46  )";
47  server.send(200, "text/html", response);
48}
49
50void setup(void) {
51  Serial.begin(115200);
52  setupLightsAndBuzzer();
53  setupServos();
54  setupDisplay();
55
56  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);
57  Serial.print("Connecting to WiFi ");
58  Serial.print(WIFI_SSID);
59  while (WiFi.status() != WL_CONNECTED) {
60    delay(100);
61    Serial.print(".");
62  }
63  Serial.println(" Connected!");
64
65  Serial.print("IP address: ");
66  Serial.println(WiFi.localIP());
67
68  server.on("/", sendHtml);
69
70  server.on("/order", []() {
71    if (!server.hasArg("dish") || 	!server.hasArg("quantity")) {
72      server.send(400, "text/plain", "Bad Request");
73      return;
74    }
75
76    String dishId = server.arg("dish");
77    int quantity = server.arg("quantity").toInt();
78
79    DishConfig* selectedDish = nullptr;
80    for (int i = 0; i < numDishes; ++i) {
81      if (dishId == dishes[i].id) {
82        selectedDish = &dishes[i];
83        break;
84      }
85    }
86
87    if (selectedDish == nullptr) {
88      Serial.println("Unsupported dish type");
89      handleUnsupportedDish();
90      server.send(200, "text/plain", "Unsupported Dish 	Type");
91      return;
92    }
93
94    Serial.print("Preparing ");
95    Serial.print(selectedDish->name);
96    Serial.print(" x");
97    Serial.println(quantity);
98
99    handleDishPreparation(*selectedDish, quantity);
100
101    server.send(200, "text/plain", "Dish prepared");
102
103    while (true) {
104      if (digitalRead(BUTTON_PIN) == LOW) {
105        Serial.println("Button pressed");
106        dispenseDish(*selectedDish, quantity);
107        break;
108      }
109      delay(10);
110    }
111  });
112
113  server.begin();
114  Serial.println("HTTP server started");
115}
116
117void loop(void) {
118  server.handleClient();
119  delay(2);
120}
Б.2 Код файлу «ServoHandler.cpp»
1#include "ServoHandler.h"
2#include "LightBuzzerHandler.h"
3#include "DisplayHandler.h"
4#include "PinConfig.h"
5#include <Arduino.h>
6#include <ESP32Servo.h>
7
8Servo servo1;
9Servo servo2;
10Servo servo3;
11
12void setupServos() {
13  servo1.attach(SERVO1_PIN);
14  servo2.attach(SERVO2_PIN);
15  servo3.attach(SERVO3_PIN);
16}
17
18void handleDishPreparation(DishConfig dish, int quantity) 	{
19  turnOnYellowLight();
20
21  String quantityStr = "Qty: " + String(quantity);
22  displayMessage(dish.name, quantityStr.c_str());
23
24  int totalRotations = calculateRotations(dish, 	quantity);
25  const int halfRotationTime = 750;
26
27  for (int i = 0; i < totalRotations; ++i) {
28    servo1.write(0);
29    servo2.write(0);
30    delay(halfRotationTime);
31    servo1.write(180);
32    servo2.write(180);
33    delay(halfRotationTime);
34  }
35
36  servo1.write(90);
37  servo2.write(90);
38
39  turnOffYellowLight();
40  beep(1, 500);
41  turnOnGreenLight();
42  displayMessage(dish.name, "Ready");
43}
44
45void dispenseDish(DishConfig dish, int quantity) {
46  const int rotationTime = 1000;
47  int rotations = quantity * 2;
48
49  for (int i = 0; i < rotations; ++i) {
50    servo3.write(0);
51    delay(rotationTime);
52    servo3.write(180);
53    delay(rotationTime);
54  }
55
56  servo3.write(90);
57
58  turnOffAllLights();
59  displayMessage("", "");
60}
61
62int calculateRotations(DishConfig dish, int quantity) {
63  // Base rotations per quantity unit
64  int baseRotations = dish.servo1Rotations;
65
66  // Additional rotations based on difficulty level
67  int difficultyRotations = dish.difficultyLevel * 2;
68
69  // Additional rotations based on number of ingredients
70  int ingredientRotations = dish.numberOfIngredients * 1;
71
72  // Total rotations calculation
73  int totalRotations = (baseRotations + 	difficultyRotations + ingredientRotations) * quantity;
74
75  return totalRotations;
76}














ДОДАТОК В
Результат перевірки на плагіат

 
